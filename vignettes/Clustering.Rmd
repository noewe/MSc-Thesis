---
title: "Clustering"
author: 'Noémie Wellinger'
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
library(blockcluster)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
```

```{r}
# load data
all_data_hourly <- readRDS("../data/final_predictors/all_data_hourly.rds")
all_data_daily_night <- readRDS("../data/final_predictors/all_data_daily.rds") |>
  filter(daynight == "n") # only night data

# Setup
cluster_variable <- "UHI"
timestep <- "hourly"
```

```{r}
# Select data
data_to_cluster <- all_data_hourly |>
  select(time, Log_NR, UHI) |>
   pivot_wider(names_from = Log_NR, values_from = UHI)

# Set time_hour as row names
data_to_cluster <- as.data.frame(data_to_cluster)
rownames(data_to_cluster) <- data_to_cluster$time
data_to_cluster$time <- NULL
#remove all rows that contain NA
data_to_cluster <- data_to_cluster[complete.cases(data_to_cluster),]

# Convert to matrix
matrix_to_cluster <- as.matrix(data_to_cluster)

# Ensure row names are preserved
rownames(matrix_to_cluster) <- rownames(data_to_cluster)
```


```{r}
# Define the number of clusters (tune this parameter)
num_row_clusters <- 6  # Time periods 
num_col_clusters <- 7  # Stations

set.seed(124)  # For reproducibility
# Run co-clustering
result <- coclusterContinuous(matrix_to_cluster, nbcocluster = c(num_row_clusters, num_col_clusters))
plot(result)
# save the plot
ggsave(paste0("../results/Clusters/CoCluster_", timestep, "_", num_col_clusters, "S_", num_row_clusters, "T.png"), cocluster_plot)
```




```{r}
print(result@rowclass)  # Time clusters
print(result@colclass)  # Station clusters
```

```{r}
# Attach the cluster classes to the original data
# Convert to data frames for merging

# Extract row (time) and column (station) cluster assignments
time_cluster_df <- data.frame(time = rownames(matrix_to_cluster), time_cluster = result@rowclass)
time_cluster_df$time <- as.POSIXct(time_cluster_df$time, format = "%Y-%m-%d %H:%M:%S", tz = "Europe/Zurich")
station_cluster_df <- data.frame(Log_NR = colnames(matrix_to_cluster), station_cluster = result@colclass)

# Merge time clusters with original data
all_data_hourly_clusters <- all_data_hourly |>
  left_join(time_cluster_df, by = "time") |>
  left_join(station_cluster_df, by = "Log_NR")
```

Mapping
```{r}
# group by time_cluster and Log_NR and summarize
time_clusters_UHI <- all_data_hourly_clusters %>%
  group_by(time_cluster, Log_NR) %>%
  summarize(UHI = mean(UHI, na.rm = TRUE)) |>
  left_join(meta, by = "Log_NR")
```

```{r}
# for all the values of time_cluster, plot the UHI_mean
for(i in 0:5){
  p <- time_clusters_UHI |>
    filter(time_cluster == i) |>
    ggplot(aes(x = OST_CHTOPO, y = NORD_CHTOPO, fill = UHI)) +
      geom_point(      
        color = "black",
        shape = 21,
        size = 4,
        stroke = 0.4) +
      labs(title = paste("Hourly Time Cluster N°", i), 
           fill = "UHI",
           x = "Longitude", y = "Latitude") +
      theme(legend.position = "bottom") +
      # Use color palette RdYlBu with midpoint at 0
      #scale_color_gradient2(low = "blue", mid = "beige", high = "red", midpoint = 0, limits= c(-5, 5)) +
      scale_fill_viridis_c(name = "UHI [K]", limits= c(-5, 5)) +
      coord_equal(expand = FALSE) +
      theme_bw()
  print(p)
  
  # save the plot
  ggsave(paste0("../results/Clusters/TimeCluster_", timestep, "_", i, cluster_variable, ".png"), p)
}
```

```{r}
# custom color palette for cluster values
cluster_colors <- c('#66c2a5','#fc8d62','#8da0cb','#e78ac3','#a6d854','#ffd92f')

# Look at the distribution of UHI_mean for each time cluster
time_clusters_UHI |>
  ggplot(aes(x = UHI, fill = factor(time_cluster))) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Distribution of UHI_mean by Time Cluster", fill = "Time Cluster") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = cluster_colors)

```

```{r}
# Plot the hour of day (y axis) and date (y axis) for each data point in data_long_hourly_clusters
all_data_hourly_clusters |>
  mutate(date = as.Date(time),
         hour = hour(time)) |>
  ggplot(aes(x = date, y = hour, fill = factor(time_cluster))) +
  geom_tile() +
  theme_minimal() +
  labs(title = paste(cluster_variable, "Time Cluster Assignments"), fill = "Time Cluster") +
  scale_fill_manual(values = cluster_colors)

# same plot just for months August and September
all_data_hourly_clusters |>
  mutate(date = as.Date(time),
         hour = hour(time)) |>
  filter(date >= "2024-08-01" & date <= "2024-09-30") |>
  ggplot() +
  geom_tile(aes(x = date, y = hour, fill = factor(time_cluster))) +
  theme_minimal() +
  labs(title = paste(cluster_variable, "Time Cluster Assignments (August and September)"), fill = "Time Cluster") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = cluster_colors)
  # plot a line with the average temperature for each day from daily_summary
  #geom_line(data = daily_summary, aes(x = time_day, y = T_mean_day, color = "red"), size = 1) 

```


2. Night mean clusters
```{r}
# load data
all_data_daily_night <- readRDS("../data/final_predictors/all_data_daily.rds") |>
  filter(daynight == "n") # only night data

# Setup
cluster_variable <- "UHI"
timestep <- "night"
```

```{r}
# Select data
data_to_cluster <- all_data_daily_night |>
  select(time, Log_NR, UHI) |>
   pivot_wider(names_from = Log_NR, values_from = UHI)

# Set time_hour as row names
data_to_cluster <- as.data.frame(data_to_cluster)
rownames(data_to_cluster) <- data_to_cluster$time
data_to_cluster$time <- NULL
#remove all rows that contain NA
data_to_cluster <- data_to_cluster[complete.cases(data_to_cluster),]

# Convert to matrix
matrix_to_cluster <- as.matrix(data_to_cluster)

# Ensure row names are preserved
rownames(matrix_to_cluster) <- rownames(data_to_cluster)
```


```{r}
# Define the number of clusters (tune this parameter)
num_row_clusters <- 4  # Time periods 
num_col_clusters <- 7  # Stations

set.seed(124)  # For reproducibility
# Run co-clustering
result <- coclusterContinuous(matrix_to_cluster, nbcocluster = c(num_row_clusters, num_col_clusters))
plot(result)
# save the plot
ggsave(paste0("../results/Clusters/CoCluster_", timestep, "_", num_col_clusters, "S_", num_row_clusters, "T.png"), cocluster_plot)
```




```{r}
print(result@rowclass)  # Time clusters
print(result@colclass)  # Station clusters
```

```{r}
# Attach the cluster classes to the original data
# Convert to data frames for merging

# Extract row (time) and column (station) cluster assignments
time_cluster_df <- data.frame(time = rownames(matrix_to_cluster), time_cluster = result@rowclass)
time_cluster_df$time <- as.POSIXct(time_cluster_df$time, format = "%Y-%m-%d", tz = "Europe/Zurich")
station_cluster_df <- data.frame(Log_NR = colnames(matrix_to_cluster), station_cluster = result@colclass)

# Merge time clusters with original data
all_data_daily_night_clusters <- all_data_daily_night |>
  left_join(time_cluster_df, by = "time") |>
  left_join(station_cluster_df, by = "Log_NR")
```

Mapping
```{r}
# group by time_cluster and Log_NR and summarize
time_clusters_UHI <- all_data_daily_night_clusters %>%
  group_by(time_cluster, Log_NR) %>%
  summarize(UHI = mean(UHI, na.rm = TRUE)) |>
  left_join(meta, by = "Log_NR")
```

```{r}
# for all the values of time_cluster, plot the UHI_mean
for(i in 0:5){
  p <- time_clusters_UHI |>
    filter(time_cluster == i) |>
    ggplot(aes(x = OST_CHTOPO, y = NORD_CHTOPO, fill = UHI)) +
      geom_point(      
        color = "black",
        shape = 21,
        size = 4,
        stroke = 0.4) +
      labs(title = paste("Hourly Time Cluster N°", i), 
           fill = "UHI",
           x = "Longitude", y = "Latitude") +
      theme(legend.position = "bottom") +
      # Use color palette RdYlBu with midpoint at 0
      #scale_color_gradient2(low = "blue", mid = "beige", high = "red", midpoint = 0, limits= c(-5, 5)) +
      scale_fill_viridis_c(name = "UHI [K]", limits= c(-1, 5.1)) +
      coord_equal(expand = FALSE) +
      theme_bw()
  print(p)
  
  # save the plot
  ggsave(paste0("../results/Clusters/TimeCluster_", timestep, "_", i, cluster_variable, ".png"), p)
}
```

```{r}
# custom color palette for cluster values
cluster_colors <- c('#a6d854','#fc8d62','#8da0cb','#e78ac3','#66c2a5','#ffd92f')

# Look at the distribution of UHI_mean for each time cluster
time_clusters_UHI |>
  ggplot(aes(x = UHI, fill = factor(time_cluster))) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "Distribution of UHI_mean by Time Cluster", fill = "Time Cluster") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = cluster_colors)

```

```{r}
# Plot the hour of day (y axis) and date (y axis) for each data point in data_long_hourly_clusters
all_data_daily_night_clusters |>
  mutate(date = as.Date(time),
         hour = 0) |>
  ggplot(aes(x = date, y = hour, fill = factor(time_cluster))) +
  geom_tile() +
  theme_minimal() +
  labs(title = paste(cluster_variable, "Time Cluster Assignments"), fill = "Time Cluster") +
  scale_fill_manual(values = cluster_colors)

# same plot just for months August and September
all_data_daily_night_clusters |>
  mutate(date = as.Date(time),
         hour = 0) |>
  filter(date >= "2024-08-01" & date <= "2024-09-30") |>
  ggplot() +
  geom_tile(aes(x = date, y = hour, fill = factor(time_cluster))) +
  theme_minimal() +
  labs(title = paste(cluster_variable, "Time Cluster Assignments (August and September)"), fill = "Time Cluster") +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = cluster_colors)
  # plot a line with the average temperature for each day from daily_summary
  #geom_line(data = daily_summary, aes(x = time_day, y = T_mean_day, color = "red"), size = 1) 

```

```{r}
# map clusters for different meteorological variables
all_data_daily_night_clusters |>
  select(time, Log_NR, UHI, time_cluster, station_cluster,
         air_temp, humidity, wind_vel, wind_dir_class, rad_1d, pressure, precip_1d)


# Define the variables to normalize
vars_to_normalize <- c("air_temp", "humidity", "wind_vel", "rad_1d", "pressure", "precip_1d")

# Normalize variables to 0–1 range
normalized_data <- all_data_daily_night_clusters |>
  mutate(across(all_of(vars_to_normalize), ~ (. - min(., na.rm = TRUE)) / 
                                            (max(., na.rm = TRUE) - min(., na.rm = TRUE)))) |>
  select(time_cluster, all_of(vars_to_normalize)) |>
  pivot_longer(cols = all_of(vars_to_normalize), 
               names_to = "variable", values_to = "value") |>
  filter(!is.na(value))

# Plot
normalized_data |>
  mutate(time_cluster = factor(time_cluster, levels = unique(time_cluster))) |>
  group_by(time_cluster) |>
ggplot(aes(x = time_cluster, y = value, fill = time_cluster)) +
  geom_boxplot(outlier.size = 0.5) +
  facet_wrap(~variable, scales = "free_y") +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Time Cluster", y = "Normalized Value", title = "Distribution of Normalized Variables by Time Cluster") +
  theme_minimal() +
  theme(legend.position = "none") +
  # arrange the time cluster in the order 0, 3, 1, 2, NA on the x axis
  scale_x_discrete(limits = c("0", "3", "1", "2", NA)) +
  scale_fill_manual(values = c("0" = "#a6d854", "3" = "#e78ac3", "1" = "#fc8d62", "2" = "#8da0cb"))

ggsave("../results/Clusters/Normalized_Variables_by_Time_Cluster_nightly.png", width = 6, height = 4, dpi = 400)

```

